[Props 속성을 사용해서 데이터를 전달하는 예제]
예제 코드에서 child-component를 전역으로 등록한 것 이외에 딱히 상위 컴포넌트를 지정하지 않았다.
그럼에도 불구하고 뷰 인스턴스 안에 마치 상위 컴포넌트가 존재하는 것처럼 하위 컴포넌트로 props를 내려보냈다.
그 이유는 컴포넌트를 등록함과 동시에 뷰 인스턴스 자체가 상위 컴포넌트가 되기 때문이다.
인스턴스에 새로운 컴포넌트를 등록하면 기존에 있는 컴포넌트는 상위 컴포넌트(부모)가 되고,
새로 등록된 컴포넌트는 하위(자식) 컴포넌트가 된다. 그리고 이렇게 새 컴포넌트를 등록한 인스턴스를
최상위 컴포넌트(Root Component)라고도 부른다.

[하위에서 상위 컴포넌트로 이벤트 전달하기]
이벤트 발생과 수신
props는 상위에서 하위 컴포넌트로 데이터를 전달하는 방식이다. 그럼 반대로 하위 컴포넌트에서 상위 컴포넌트로의 통신은 어떻게 할까?
이벤트를 발생시켜(event emit) 상위 컴포넌트에 신호를 보내면 된다.
상위 컴포넌트에서 하위 컴포넌트의 특정 이벤트가 발생하기를 기다리고 있다가 하위 컴포넌트에서 특정 이벤트가 발생하면
상위 컴포넌트에서 해당 이벤트를 수신하여 상위 컴포넌트의 메서드를 호출하는 것이다.

*하위에서 상위로 데이터를 전달할 수 없을까?
    뷰 공식 사이트의 이벤트 발생 사용방법에서는 하위에서 상위로 데이터를 전달하는 방법을 다루지 않는다.
    왜냐하면 이는 뷰의 단방향 데이터 흐름에 어긋나는 구현 방법이기 때문이다. 하지만 향후에 복잡한 뷰
    애플리케이션을 구축할 때 이벤트 버스(Event Bus)를 이용하여 데이터를 전달해야 할 경우가 있기 때문에
    이벤트 인자로 데이터를 전달하는 방법에 대해서는 버스 부분을 참조한다.

<이벤트 발생과 수신 형식>
이벤트 발생과 수신은 $emit() 와 v-on 속성을 사용하여 구현한다.
this.$emit('이벤트명');  //emit()을 이용한 이벤트 발생
<child-component v-on:이벤트명="상위컴포넌트의메소드명"></child-component> //v-on 속성을이용한 이벤트수신

$emit()을 호출하면 괄호 안에 정의된 이벤트가 발생한다. 그리고 일반적으로 $emit()을 호출하는 위치는 하위 컴포넌트의 특정 메서드 내부이다.
따라서 $emit()을 호출할 때 사용하는 this는 하위 컴포넌트를 가리킨다.
호출한 이벤트는 하위 컴포넌트를 등록하는 태그(상위 컴포넌트의 template 속성에서 위치)에서 v-on:으로 받는다.
하위 컴포넌트에서 발생한 이벤트명을 v-on:속성에 지정하고, 속성의 값에 이벤트가 발생했을 때 호출될 상위 컴포넌트의 메소드를 지정한다.

[같은 레벨의 컴포넌트 간 통신]
뷰는 상위에서 하위로만 데이터를 전달해야 하는 기본적인 통신 규칙을 따르기 때문에 바로 옆 컴포넌트에 값을 전달하려면
하위에서 공통 상위 컴포넌트로 이벤트를 전달한 후 공통 상위 컴포넌트에서 2개의 하위 컴포넌트에 props를 내려보내야한다.
이런 방식으로 통신해야 하는 이유는 컴포넌트 고유의 유효 범위 때문이다. 다른 컴포넌트의 값을 직접 참조하지 못하므로
기본적인 데이터 전달 방식을 활용하여 같은 레벨 간에 통신이 가능하도록 구조를 갖춰야한다.
하지만 이런 통신 구조를 유지하다 보면 상위 컴포넌트가 필요 없음에도 불구하고 같은 레벨 간에 통신하기 위해
강제로 상위 컴포넌트를 두어야한다. 이를 해결할 수 있는 방법이 바로 '이벤트버스'이다.
<관계 없는 컴포넌트간 통신 - 이벤트 버스>
Event Bus는 개발자가 지정한 2개의 컴포넌트 간에 데이터를 주고 받을 수 있는 방법이다. 앞서 배운 컴포넌트 통신은
항상 상위 - 하위 구조를 유지해야만 데이터를 주고 받을 수 있었다. 이벤트 버스를 이용하면 이런 상.하위 관계를 유지하고 있지 않아도 데이터를 전달받을 수 있다.

<이벤트 버스 형식>
// 이벤트 버스를 위한 추가 인스턴스 1개 생성
var eventBus = new Vue();

// 이벤트를 보내는 컴포넌트
methods: {
    메소드명: function() {
        eventBus.$emit('이벤트명',데이터);
    }
}

// 이벤트를 받는 컴포넌트
methods: {
    created: function() {
        eventBus.$on('이벤트명', function(데이터) {
            ...
        });
    }
}

이벤트버스를 구현하려면 애플리케이션 로직을 담는 인스턴스와는 별개로 새로운 인스턴스를 1개 더 생성하고, 새 인스턴스를 이용하여 이벤트를 보내고 받는다.
보내는 컴포넌트에서는 .$emit()을, 받는 컴포넌트에서는 .$on()을 구현한다.

