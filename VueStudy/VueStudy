1. 뷰 컴포넌트
컴포넌트란 조합하여 화면을 구성할 수 있는 블록(화면의 특정 영역)을 의미한다. 컴포넌트를 활용하면 화면을 빠르게 구조화하여 일괄적인 패턴으로 개발할 수 있다. 
이렇게 화면의 영역을 컴포넌트로 쪼개서 재활용할 수 있는 형태로 관리하면 나중에 코드를 다시 사용하기가 훨씬 편리하다.
* Vue 에서는 웹 화면을 구성할 때 화면 구성 요소들을 잘게 쪼개어 컴포넌트로 관리한다. (Header - Content - Footer 와 같이)
<Global Component 선언방법>
Vue.component('컴포넌트이름', {
    template: '<div>내용을 적는다</div>'
});

<Local Component 선언방법>
new Vue({
    components: {
        '컴포넌트 이름': abc
    }
});
var abc = {
    template: '<div>내용을 적는다</div>'
};

2. 뷰 컴포넌트 통신
[컴포넌트 간 통신과 유효 범위]
앵귤러1이나 Backbone.js와 같은 초창기 자바스크립트 프레임워크에서는 한 화면을 1개의 뷰로 간주했다.
따라서 한 화면의 데이터를 해당 화면 영역 어디서든지 호출할 수 있었다. 하지만 Vue.js의 경우 컴포넌트로
화면을 구성하므로 같은 웹 페이지라도 데이터를 공유할 수 없다. 그 이유는 컴포넌트마다 자체적으로 고유한 유효범위(scope)를 갖기 때문이다.
이는 뷰 프레임워크 내부적으로 정의된 특징이다. 각 컴포넌트의 유효범위가 독립적이기 때문에 다른 컴포넌트의 값을 직접적으로 참조할 수가 없다.

[상.하위 컴포넌트 관계]
컴포넌트는 각각 고유한 유효 범위를 갖고 있기 때문에 직접 다른 컴포넌트의 값을 참조할 수 없다.
따라서 뷰 프레임워크 자체에서 정의한 컴포넌트 데이터 전달 방법을 따라야한다. 
가장 기본적인 데이터 전달 방법은 바로 상위(부모) - 하위(자식) 컴포넌트 간의 데이터 전달 방법이다.
상위 - 하위 컴포넌트란 트리구조에서 부모노드, 자식노드처럼 컴포넌트 간의 관계가 부모, 자식으로 이루어진 컴포넌트를 의미한다.
지역 또는 전역 컴포넌트를 등록하면 등록된 컴포넌트는 자연스럽게 하위 컴포넌트(자식컴포넌트)가 된다.
그리고 하위 컴포넌트를 등록한 인스턴스는 상위 컴포넌트(부모 컴포넌트)가 된다.
*상위에서 하위로 props라는 특별한 속성을 전달하며, 하위에서 상위로는 기본적으로 이벤트만 전달할 수 있다.

[상위에서 하위 컴포넌트로 데이터 전달하기]
<props 속성>
props는 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 사용하는 속성이다. props 속성을 사용하려면 아래와 같이 먼저 하위 컴포넌트의 속성에 정의해야한다.
Vue.component('child-component', {
    props: ['props 속성 이름'],
});

그런 다음 상위 컴포넌트의 HTML 코드에 등록된 child-component 태그에 v-bind 속성을 추가한다.
<child-component v-bind:props속성이름="상위컴포넌트의data속성"></child-component>

v-bind 속성의 왼쪽 값으로 하위 컴포넌트에서 정의한 props 속성을 넣고, 오른쪽 값으로 하위컴포넌트에 전달할 상위 컴포넌트의 data 속성을 지정한다.
* 2-2.props속성을사용한데이터전달예제.html 참조

[Props 속성을 사용해서 데이터를 전달하는 예제]
예제 코드에서 child-component를 전역으로 등록한 것 이외에 딱히 상위 컴포넌트를 지정하지 않았다.
그럼에도 불구하고 뷰 인스턴스 안에 마치 상위 컴포넌트가 존재하는 것처럼 하위 컴포넌트로 props를 내려보냈다.
그 이유는 컴포넌트를 등록함과 동시에 뷰 인스턴스 자체가 상위 컴포넌트가 되기 때문이다.
인스턴스에 새로운 컴포넌트를 등록하면 기존에 있는 컴포넌트는 상위 컴포넌트(부모)가 되고,
새로 등록된 컴포넌트는 하위(자식) 컴포넌트가 된다. 그리고 이렇게 새 컴포넌트를 등록한 인스턴스를
최상위 컴포넌트(Root Component)라고도 부른다.

[하위에서 상위 컴포넌트로 이벤트 전달하기]
이벤트 발생과 수신
props는 상위에서 하위 컴포넌트로 데이터를 전달하는 방식이다. 그럼 반대로 하위 컴포넌트에서 상위 컴포넌트로의 통신은 어떻게 할까?
이벤트를 발생시켜(event emit) 상위 컴포넌트에 신호를 보내면 된다.
상위 컴포넌트에서 하위 컴포넌트의 특정 이벤트가 발생하기를 기다리고 있다가 하위 컴포넌트에서 특정 이벤트가 발생하면
상위 컴포넌트에서 해당 이벤트를 수신하여 상위 컴포넌트의 메서드를 호출하는 것이다.

*하위에서 상위로 데이터를 전달할 수 없을까?
    뷰 공식 사이트의 이벤트 발생 사용방법에서는 하위에서 상위로 데이터를 전달하는 방법을 다루지 않는다.
    왜냐하면 이는 뷰의 단방향 데이터 흐름에 어긋나는 구현 방법이기 때문이다. 하지만 향후에 복잡한 뷰
    애플리케이션을 구축할 때 이벤트 버스(Event Bus)를 이용하여 데이터를 전달해야 할 경우가 있기 때문에
    이벤트 인자로 데이터를 전달하는 방법에 대해서는 버스 부분을 참조한다.

<이벤트 발생과 수신 형식>
이벤트 발생과 수신은 $emit() 와 v-on 속성을 사용하여 구현한다.
this.$emit('이벤트명');  //emit()을 이용한 이벤트 발생
<child-component v-on:이벤트명="상위컴포넌트의메소드명"></child-component> //v-on 속성을이용한 이벤트수신

$emit()을 호출하면 괄호 안에 정의된 이벤트가 발생한다. 그리고 일반적으로 $emit()을 호출하는 위치는 하위 컴포넌트의 특정 메서드 내부이다.
따라서 $emit()을 호출할 때 사용하는 this는 하위 컴포넌트를 가리킨다.
호출한 이벤트는 하위 컴포넌트를 등록하는 태그(상위 컴포넌트의 template 속성에서 위치)에서 v-on:으로 받는다.
하위 컴포넌트에서 발생한 이벤트명을 v-on:속성에 지정하고, 속성의 값에 이벤트가 발생했을 때 호출될 상위 컴포넌트의 메소드를 지정한다.

[같은 레벨의 컴포넌트 간 통신]
뷰는 상위에서 하위로만 데이터를 전달해야 하는 기본적인 통신 규칙을 따르기 때문에 바로 옆 컴포넌트에 값을 전달하려면
하위에서 공통 상위 컴포넌트로 이벤트를 전달한 후 공통 상위 컴포넌트에서 2개의 하위 컴포넌트에 props를 내려보내야한다.
이런 방식으로 통신해야 하는 이유는 컴포넌트 고유의 유효 범위 때문이다. 다른 컴포넌트의 값을 직접 참조하지 못하므로
기본적인 데이터 전달 방식을 활용하여 같은 레벨 간에 통신이 가능하도록 구조를 갖춰야한다.
하지만 이런 통신 구조를 유지하다 보면 상위 컴포넌트가 필요 없음에도 불구하고 같은 레벨 간에 통신하기 위해
강제로 상위 컴포넌트를 두어야한다. 이를 해결할 수 있는 방법이 바로 '이벤트버스'이다.
<관계 없는 컴포넌트간 통신 - 이벤트 버스>
Event Bus는 개발자가 지정한 2개의 컴포넌트 간에 데이터를 주고 받을 수 있는 방법이다. 앞서 배운 컴포넌트 통신은
항상 상위 - 하위 구조를 유지해야만 데이터를 주고 받을 수 있었다. 이벤트 버스를 이용하면 이런 상.하위 관계를 유지하고 있지 않아도 데이터를 전달받을 수 있다.

<이벤트 버스 형식>
// 이벤트 버스를 위한 추가 인스턴스 1개 생성
var eventBus = new Vue();

// 이벤트를 보내는 컴포넌트
methods: {
    메소드명: function() {
        eventBus.$emit('이벤트명',데이터);
    }
}

// 이벤트를 받는 컴포넌트
methods: {
    created: function() {
        eventBus.$on('이벤트명', function(데이터) {
            ...
        });
    }
}

이벤트버스를 구현하려면 애플리케이션 로직을 담는 인스턴스와는 별개로 새로운 인스턴스를 1개 더 생성하고, 새 인스턴스를 이용하여 이벤트를 보내고 받는다.
보내는 컴포넌트에서는 .$emit()을, 받는 컴포넌트에서는 .$on()을 구현한다.

